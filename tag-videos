#! /usr/bin/perl

# Copyright (c) 2024 Marc Espie <espie@openbsd.org>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use v5.36;

# XXX this actually expects Gnu Readline for tab completion to work
use Term::ReadLine;
use Data::Dumper;
use File::Spec;
use FindBin;
use Getopt::Std;
use lib "$FindBin::Bin/lib";
use TagVideos::Model;

use locale;
my $opts;

if (!getopts('c:d:', $opts) || @ARGV != 1) {
	say STDERR "Usage: $0 [-c cwd] [-d database] path";
	exit 1;
}

# as it stands the script gets two parameters: cwd + path name

my $path = File::Spec->rel2abs($ARGV[0], $opts->{c});

say "Filename is: $path";

my $db = TagVideos::Model->connect($opts->{d});
$db->set_path($path);

my $term = Term::ReadLine->new("tag-videos");
my $attribs = $term->Attribs;
$attribs->{completion_entry_function} = $attribs->{list_completion_function};

sub list_tags
{
	my $tags = $db->find_tags;

	say "Tags: ", join(' ', @$tags);
}

sub prepare_completions
{
	$attribs->{completion_word} = 
		$db->selectcol_arrayref('alltags');
}

sub parse_tags($words, $f)
{
	for my $tag (split /\s+/, lc($words)) {
		&$f($tag);
	}
}

sub pretty_print_suggestions($h)
{
	my @l;
	for my $k (sort {
		$h->{$a} != $h->{$b} ?
		$h->{$b} <=> $h->{$a} : $a cmp $b } keys %$h) {
		push(@l, "$k($h->{$k})");
	}
	return @l;
}

list_tags();

while (defined ($_ = $term->readline('> '))) {
	prepare_completions();
	if (m/^(?:add|t)\b\s*(.*)/i) {
		parse_tags($1, 
		    sub($tag) {
			$db->create_tag($tag);
		    });
	} elsif (m/^rm\b\s*(.*)/i) {
		parse_tags($1, 
		    sub($tag) {
			$db->delete_tag($tag);
		    });
	} elsif (m/^suggest\b\s*(.*)/i) {
		parse_tags($1,
		    sub($tag) {
			my $tags = $db->suggestions($tag);
			say "Suggestions: ", join(' ', pretty_print_suggestions($tags));
		    });
	} elsif (m/^list\s*$/i) {
		list_tags();
	} elsif (m/^known\b\s*(.*)$/) {
		my $filter = $1;
		prepare_completions();
		my @tags = @{$attribs->{completion_word}};
		if ($filter ne '') {
			@tags = grep { /\Q$filter\E/ } @tags;
		}
		say "known tags: ", join(' ', @tags);
	} elsif (m/^help\s*/i) {
		say "help/add/t/rm/rename/list/suggest/known/quit"
	} elsif (m/^(?:quit|q)\s*$/i) {
		$db->cleanup;
		exit;
	} elsif (m/^rename\b\s*/i) {
		if (m/^rename\s+(\S+)\s+(\S+)\s*$/) {
			$db->rename_tag(lc($1), lc($2));
		} else {
			say "Error: rename oldtag newtag";
		}
	} elsif (m/^\s*$/) {
		# nothing !
	} else {
		say "Unknown command $_";
	}
}
